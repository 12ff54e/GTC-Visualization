importScripts('javascripts/gtc-output-parser.min.js'); // expose GTCOutput

const cacheName = '|@_@|/'; // name to be replaced by hash
const staticFiles = [];
let currentOutput;

addEventListener('install', event => {
    skipWaiting();
    event.waitUntil(updateCache());

    console.log('A new version of service worker is installed.');
});

addEventListener('activate', event => {
    // The deletion of old caches must be done before worker can handle any fetch
    // in case obsolete caches being provided for response
    event.waitUntil(clearCache());
});

addEventListener('fetch', event => {
    const url = new URL(event.request.url);
    const local_patten = /^\/local\//;
    if (local_patten.test(url.pathname)) {
        if (url.pathname === '/local/plot') {
            // The webpage is generated by server
            return;
        }
        event.respondWith(processLocalRequest(event));
    } else if (staticFiles.length > 0) {
        event.respondWith(cacheFirst(event));
    }
});

addEventListener(
    'message',
    wrap(async event => {
        const files = event.data;
        const outputFiles = files.filter(file =>
            inTopLevelFolder(file.webkitRelativePath)
        );

        currentOutput = new GTCOutput('', outputFiles);
        event.source.postMessage({
            done: true,
            snapshotFiles: await currentOutput.getSnapshotFileList(),
        });
    })
);

async function updateCache() {
    return (await caches.open(cacheName)).addAll(staticFiles);
}

async function clearCache() {
    await Promise.all(
        (
            await caches.keys()
        ).map(async key => {
            if (!key.startsWith('GTC-Visualization') && key !== cacheName) {
                await caches.delete(key);
            }
        })
    );
    console.log('Obsolete cache cleared.');
}

/**
 *
 * @param {Event} event
 */
async function processLocalRequest(event) {
    const pathname = new URL(event.request.url).pathname.slice(7); // truncate the leading /local/
    let match;
    if ((match = pathname.match(/^plot\/plotType\/(?<type>[\w\.]+)/))) {
        const filename = match.groups.type;
        await currentOutput.readData(filename);
        const type = filename.startsWith('snap') ? 'Snapshot' : filename;
        const data = currentOutput.data[type];

        const status = {
            info: `${type} file read`,
            id: data.plotTypes,
        };
        if (!data.isCompleted) {
            status.warn =
                `${data.filename} is not completed. It should have ` +
                `${data.expectedStepNumber} steps, but only contains ${data.stepNumber} step.`;
        }
        if (type === 'Snapshot') {
            status.info = `Currently selection of Snapshot file: ${filename}`;
        }
        return Response.json(status);
    } else if (
        (match = pathname.match(/^plot\/data\/(?<type>\w+)-(?<id>[\w_-]+)/))
    ) {
        const { type, id } = match.groups;
        try {
            return Response.json(currentOutput.getPlotData(type, id));
        } catch (e) {
            console.error(e);
            return new Response('Not found!', { status: 404 });
        }
    } else if (pathname.match(/^plot\/data\/basicParameters/)) {
        return Response.json(await currentOutput.getParameters());
    } else if (pathname.match(/^plot\/Summary/)) {
        // TODO: Finish it!
    }
}

async function cacheFirst(event) {
    const cache = await caches.open(currentCacheName);
    let response = await cache.match(event.request);
    if (!response) {
        response = await fetch(event.request);
    }
    return response;
}

function inTopLevelFolder(pathname) {
    return !pathname.match(/[^\/]+\/[^\/]+\//);
}

function wrap(func) {
    return (...args) =>
        func(...args).catch(err => {
            console.error(err);
        });
}
