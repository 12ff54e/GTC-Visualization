/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/FFTW.js":
/*!*********************!*\
  !*** ./src/FFTW.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, __dirname) {var FFTWModule = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (FFTWModule) {\n    FFTWModule = FFTWModule || {}; // Copyright 2010 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n\n    var Module = typeof FFTWModule !== 'undefined' ? FFTWModule : {}; // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n    // {{PRE_JSES}}\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    Module['arguments'] = [];\n    Module['thisProgram'] = './this.program';\n\n    Module['quit'] = function (status, toThrow) {\n      throw toThrow;\n    };\n\n    Module['preRun'] = [];\n    Module['postRun'] = []; // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n    ENVIRONMENT_IS_NODE = typeof process === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n    } // Three configurations we can be running in:\n    // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n    // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n    // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n    // `/` should be present at the end if `scriptDirectory` is not empty\n\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + '/'; // Expose functionality in the same simple way that the shells work\n      // Note that we pollute the global namespace here, otherwise we break in node\n\n      var nodeFS;\n      var nodePath;\n\n      Module['read'] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      Module['readBinary'] = function readBinary(filename) {\n        var ret = Module['read'](filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process['argv'].length > 1) {\n        Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n      }\n\n      Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n      process['on']('uncaughtException', function (ex) {\n        // suppress ExitStatus exceptions from showing an error\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      }); // Currently node will swallow unhandled rejections, but this behavior is\n      // deprecated, and in the future it will exit with error status.\n\n      process['on']('unhandledRejection', abort);\n\n      Module['quit'] = function (status) {\n        process['exit'](status);\n      };\n\n      Module['inspect'] = function () {\n        return '[Emscripten Module object]';\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != 'undefined') {\n        Module['read'] = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      Module['readBinary'] = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === 'function') {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, 'binary');\n        assert(typeof data === 'object');\n        return data;\n      };\n\n      if (typeof scriptArgs != 'undefined') {\n        Module['arguments'] = scriptArgs;\n      } else if (typeof arguments != 'undefined') {\n        Module['arguments'] = arguments;\n      }\n\n      if (typeof quit === 'function') {\n        Module['quit'] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      } // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n\n\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n      } else {\n        scriptDirectory = '';\n      }\n\n      Module['read'] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        Module['readBinary'] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      Module['readAsync'] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      Module['setWindowTitle'] = function (title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error('environment detection error');\n    } // Set up the out() and err() hooks, which are how we can print to stdout or\n    // stderr, respectively.\n    // If the user provided Module.print or printErr, use that. Otherwise,\n    // console.log is checked first, as 'print' on the web will open a print dialogue\n    // printErr is preferable to console.warn (works better in shells)\n    // bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\n\n\n    var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null);\n    var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn.bind(console) || out); // Merge back in the overrides\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    } // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n    moduleOverrides = undefined; // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n\n    assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead'); // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // {{PREAMBLE_ADDITIONS}}\n\n    var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n    // should not be used before it is ready\n\n    stackSave = stackRestore = stackAlloc = function () {\n      abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n    };\n\n    function staticAlloc(size) {\n      abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n    }\n\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n\n      if (end >= TOTAL_MEMORY) {\n        var success = enlargeMemory();\n\n        if (!success) {\n          HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n          return 0;\n        }\n      }\n\n      return ret;\n    }\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n      return Math.ceil(size / factor) * factor;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case 'i1':\n        case 'i8':\n          return 1;\n\n        case 'i16':\n          return 2;\n\n        case 'i32':\n          return 4;\n\n        case 'i64':\n          return 8;\n\n        case 'float':\n          return 4;\n\n        case 'double':\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === '*') {\n              return 4; // A pointer\n            } else if (type[0] === 'i') {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n\n    var asm2wasmImports = {\n      // special asm2wasm imports\n      \"f64-rem\": function (x, y) {\n        return x % y;\n      },\n      \"debugger\": function () {\n        debugger;\n      }\n    };\n    var jsCallStartIndex = 1;\n    var functionPointers = new Array(0); // Add a wasm function to the table.\n    // Attempting to call this with JS function will cause of table.set() to fail\n\n    function addWasmFunction(func) {\n      var table = Module['wasmTable'];\n      var ret = table.length;\n      table.grow(1);\n      table.set(ret, func);\n      return ret;\n    } // 'sig' parameter is currently only used for LLVM backend under certain\n    // circumstance: RESERVED_FUNCTION_POINTERS=1, EMULATED_FUNCTION_POINTERS=0.\n\n\n    function addFunction(func, sig) {\n      var base = 0;\n\n      for (var i = base; i < base + 0; i++) {\n        if (!functionPointers[i]) {\n          functionPointers[i] = func;\n          return jsCallStartIndex + i;\n        }\n      }\n\n      throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n    }\n\n    function removeFunction(index) {\n      functionPointers[index - jsCallStartIndex] = null;\n    }\n\n    var funcWrappers = {};\n\n    function getFuncWrapper(func, sig) {\n      if (!func) return; // on null pointer, return undefined\n\n      assert(sig);\n\n      if (!funcWrappers[sig]) {\n        funcWrappers[sig] = {};\n      }\n\n      var sigCache = funcWrappers[sig];\n\n      if (!sigCache[func]) {\n        // optimize away arguments usage in common cases\n        if (sig.length === 1) {\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func);\n          };\n        } else if (sig.length === 2) {\n          sigCache[func] = function dynCall_wrapper(arg) {\n            return dynCall(sig, func, [arg]);\n          };\n        } else {\n          // general case\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func, Array.prototype.slice.call(arguments));\n          };\n        }\n      }\n\n      return sigCache[func];\n    }\n\n    function makeBigInt(low, high, unsigned) {\n      return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (args && args.length) {\n        assert(args.length == sig.length - 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n      } else {\n        assert(sig.length == 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].call(null, ptr);\n      }\n    }\n\n    var tempRet0 = 0;\n\n    var setTempRet0 = function (value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function () {\n      return tempRet0;\n    };\n\n    function getCompilerSetting(name) {\n      throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n    }\n\n    var Runtime = {\n      // FIXME backwards compatibility layer for ports. Support some Runtime.*\n      //       for now, fix it there, then remove it from here. That way we\n      //       can minimize any period of breakage.\n      dynCall: dynCall,\n      // for SDL2 port\n      // helpful errors\n      getTempRet0: function () {\n        abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      staticAlloc: function () {\n        abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      stackAlloc: function () {\n        abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      }\n    }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n    // Above 0 is static memory, starting with globals.\n    // Then the stack.\n    // Then 'dynamic' memory for sbrk.\n\n    var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n    //========================================\n    // Runtime essentials\n    //========================================\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n\n    var ABORT = false; // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n\n    var EXITSTATUS = 0;\n    /** @type {function(*, string=)} */\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed: ' + text);\n      }\n    }\n\n    var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n    function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    }\n\n    var JSfuncs = {\n      // Helpers for cwrap -- it can't refer to Runtime directly because it might\n      // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n      // out what the minified function name is.\n      'stackSave': function () {\n        stackSave();\n      },\n      'stackRestore': function () {\n        stackRestore();\n      },\n      // type conversion from js to c\n      'arrayToC': function (arr) {\n        var ret = stackAlloc(arr.length);\n        writeArrayToMemory(arr, ret);\n        return ret;\n      },\n      'stringToC': function (str) {\n        var ret = 0;\n\n        if (str !== null && str !== undefined && str !== 0) {\n          // null string\n          // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n          var len = (str.length << 2) + 1;\n          ret = stackAlloc(len);\n          stringToUTF8(str, ret, len);\n        }\n\n        return ret;\n      }\n    }; // For fast lookup of conversion functions\n\n    var toC = {\n      'string': JSfuncs['stringToC'],\n      'array': JSfuncs['arrayToC']\n    }; // C calling interface.\n\n    function ccall(ident, returnType, argTypes, args, opts) {\n      function convertReturnValue(ret) {\n        if (returnType === 'string') return Pointer_stringify(ret);\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0) stackRestore(stack);\n      return ret;\n    }\n\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    }\n    /** @type {function(number, number, string, boolean=)} */\n\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i8':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case 'i64':\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort('invalid type for setValue: ' + type);\n      }\n    }\n    /** @type {function(number, string, boolean=)} */\n\n\n    function getValue(ptr, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr >> 0];\n\n        case 'i8':\n          return HEAP8[ptr >> 0];\n\n        case 'i16':\n          return HEAP16[ptr >> 1];\n\n        case 'i32':\n          return HEAP32[ptr >> 2];\n\n        case 'i64':\n          return HEAP32[ptr >> 2];\n\n        case 'float':\n          return HEAPF32[ptr >> 2];\n\n        case 'double':\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort('invalid type for getValue: ' + type);\n      }\n\n      return null;\n    }\n\n    var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n    var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n    var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\n\n    var ALLOC_NONE = 3; // Do not allocate\n    // allocate(): This is for internal use. You can use it yourself as well, but the interface\n    //             is a little tricky (see docs right below). The reason is that it is optimized\n    //             for multiple syntaxes to save space in generated code. So you should\n    //             normally not use allocate(), and instead allocate memory using _malloc(),\n    //             initialize it with setValue(), and so forth.\n    // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n    //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n    //        affect this!)\n    // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n    //         or a single type which is used for the entire block. This only matters if there\n    //         is initial data - if @slab is a number, then this does not matter at all and is\n    //         ignored.\n    // @allocator: How to allocate memory, see ALLOC_*\n\n    /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === 'number') {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === 'string' ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === 'i8') {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(\n          /** @type {!Uint8Array} */\n          slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        assert(type, 'Must know what type to store in allocate!');\n        if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n    function getMemory(size) {\n      if (!runtimeInitialized) return dynamicAlloc(size);\n      return _malloc(size);\n    }\n    /** @type {function(number, number=)} */\n\n\n    function Pointer_stringify(ptr, length) {\n      if (length === 0 || !ptr) return ''; // Find the length, and check for UTF while doing so\n\n      var hasUtf = 0;\n      var t;\n      var i = 0;\n\n      while (1) {\n        assert(ptr + i < TOTAL_MEMORY);\n        t = HEAPU8[ptr + i >> 0];\n        hasUtf |= t;\n        if (t == 0 && !length) break;\n        i++;\n        if (length && i == length) break;\n      }\n\n      if (!length) length = i;\n      var ret = '';\n\n      if (hasUtf < 128) {\n        var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n\n        var curr;\n\n        while (length > 0) {\n          curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n          ret = ret ? ret + curr : curr;\n          ptr += MAX_CHUNK;\n          length -= MAX_CHUNK;\n        }\n\n        return ret;\n      }\n\n      return UTF8ToString(ptr);\n    } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function AsciiToString(ptr) {\n      var str = '';\n\n      while (1) {\n        var ch = HEAP8[ptr++ >> 0];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n    function stringToAscii(str, outPtr) {\n      return writeAsciiToMemory(str, outPtr, false);\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n    function UTF8ArrayToString(u8Array, idx) {\n      var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      while (u8Array[endPtr]) ++endPtr;\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var u0, u1, u2, u3, u4, u5;\n        var str = '';\n\n        while (1) {\n          // For UTF8 byte structure, see:\n          // http://en.wikipedia.org/wiki/UTF-8#Description\n          // https://www.ietf.org/rfc/rfc2279.txt\n          // https://tools.ietf.org/html/rfc3629\n          u0 = u8Array[idx++];\n          if (!u0) return str;\n\n          if (!(u0 & 0x80)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xE0) == 0xC0) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF0) == 0xE0) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u3 = u8Array[idx++] & 63;\n\n            if ((u0 & 0xF8) == 0xF0) {\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n            } else {\n              u4 = u8Array[idx++] & 63;\n\n              if ((u0 & 0xFC) == 0xF8) {\n                u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n              } else {\n                u5 = u8Array[idx++] & 63;\n                u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n              }\n            }\n          }\n\n          if (u0 < 0x10000) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 0x10000;\n            str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n          }\n        }\n      }\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function UTF8ToString(ptr) {\n      return UTF8ArrayToString(HEAPU8, ptr);\n    } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n    // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n    //   outIdx: The starting offset in the array to begin the copying.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n    //                    This count should include the null terminator,\n    //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 0xC0 | u >> 6;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 0xE0 | u >> 12;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0x1FFFFF) {\n          if (outIdx + 3 >= endIdx) break;\n          outU8Array[outIdx++] = 0xF0 | u >> 18;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0x3FFFFFF) {\n          if (outIdx + 4 >= endIdx) break;\n          outU8Array[outIdx++] = 0xF8 | u >> 24;\n          outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 5 >= endIdx) break;\n          outU8Array[outIdx++] = 0xFC | u >> 30;\n          outU8Array[outIdx++] = 0x80 | u >> 24 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        }\n      } // Null-terminate the pointer to the buffer.\n\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n        if (u <= 0x7F) {\n          ++len;\n        } else if (u <= 0x7FF) {\n          len += 2;\n        } else if (u <= 0xFFFF) {\n          len += 3;\n        } else if (u <= 0x1FFFFF) {\n          len += 4;\n        } else if (u <= 0x3FFFFFF) {\n          len += 5;\n        } else {\n          len += 6;\n        }\n      }\n\n      return len;\n    } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      var idx = endPtr >> 1;\n\n      while (HEAP16[idx]) ++idx;\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = '';\n\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) return str;\n          ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) return str;\n        ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n        len += 4;\n      }\n\n      return len;\n    } // Allocate heap space for a JS string, and write it there.\n    // It is the responsibility of the caller to free() that memory.\n\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Allocate stack space for a JS string, and write it there.\n\n\n    function allocateUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    }\n\n    function demangle(func) {\n      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + ' [' + x + ']';\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    } // Memory management\n\n\n    var PAGE_SIZE = 16384;\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n    var MIN_TOTAL_MEMORY = 16777216;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\n    function updateGlobalBuffer(buf) {\n      Module['buffer'] = buffer = buf;\n    }\n\n    function updateGlobalBufferViews() {\n      Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n      Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n      Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n    }\n\n    var STATIC_BASE = 1024,\n        STACK_BASE = 36080,\n        STACKTOP = STACK_BASE,\n        STACK_MAX = 5278960,\n        DYNAMIC_BASE = 5278960,\n        DYNAMICTOP_PTR = 35824;\n    assert(STACK_BASE % 16 === 0, 'stack must start aligned');\n    assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned'); // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0);\n      HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n      HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n    }\n\n    function checkStackCookie() {\n      if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {\n        abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n      } // Also test the global address 0 for integrity.\n\n\n      if (HEAP32[0] !== 0x63736d65\n      /* 'emsc' */\n      ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n    }\n\n    function abortStackOverflow(allocSize) {\n      abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n    }\n\n    function abortOnCannotGrowMemory() {\n      abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n\n    function enlargeMemory() {\n      abortOnCannotGrowMemory();\n    }\n\n    var TOTAL_STACK = 5242880;\n    if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');\n    var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n    if (TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n    // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n    assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one\n\n    if (Module['buffer']) {\n      buffer = Module['buffer'];\n      assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n    } else {\n      // Use a WebAssembly memory where available\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {\n        assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n        Module['wasmMemory'] = new WebAssembly.Memory({\n          'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,\n          'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = Module['wasmMemory'].buffer;\n      } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n      }\n\n      assert(buffer.byteLength === TOTAL_MEMORY);\n      Module['buffer'] = buffer;\n    }\n\n    updateGlobalBufferViews();\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\n    function getTotalMemory() {\n      return TOTAL_MEMORY;\n    } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n    HEAP32[0] = 0x63736d65;\n    /* 'emsc' */\n\n    HEAP16[1] = 0x6373;\n    if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == 'function') {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            Module['dynCall_v'](func);\n          } else {\n            Module['dynCall_vi'](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n    var __ATINIT__ = []; // functions called during startup\n\n    var __ATMAIN__ = []; // functions called when main() is to be run\n\n    var __ATEXIT__ = []; // functions called during shutdown\n\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      // compatibility - merge in anything from Module['preRun'] at this time\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function ensureInitRuntime() {\n      checkStackCookie();\n      if (runtimeInitialized) return;\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function exitRuntime() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATEXIT__);\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnExit(cb) {\n      __ATEXIT__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    } // Deprecated: This function should not be called because it is unsafe and does not provide\n    // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n    // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n    // to be secure from out of bounds writes.\n\n    /** @deprecated */\n\n\n    function writeStringToMemory(string, buffer, dontAddNull) {\n      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n      var\n      /** @type {number} */\n      lastChar,\n      /** @type {number} */\n      end;\n\n      if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don't want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n      }\n\n      stringToUTF8(string, buffer, Infinity);\n      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n      HEAP8.set(array, buffer);\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      } // Null-terminate the pointer to the HEAP.\n\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n\n    function unSign(value, bits, ignore) {\n      if (value >= 0) {\n        return value;\n      }\n\n      return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n      : Math.pow(2, bits) + value;\n    }\n\n    function reSign(value, bits, ignore) {\n      if (value <= 0) {\n        return value;\n      }\n\n      var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n      : Math.pow(2, bits - 1);\n\n      if (value >= half && (bits <= 32 || value > half)) {\n        // for huge values, we can hit the precision limit and always get true here. so don't do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n      }\n\n      return value;\n    }\n\n    assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_tan = Math.tan;\n    var Math_acos = Math.acos;\n    var Math_asin = Math.asin;\n    var Math_atan = Math.atan;\n    var Math_atan2 = Math.atan2;\n    var Math_exp = Math.exp;\n    var Math_log = Math.log;\n    var Math_sqrt = Math.sqrt;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_pow = Math.pow;\n    var Math_imul = Math.imul;\n    var Math_fround = Math.fround;\n    var Math_round = Math.round;\n    var Math_min = Math.min;\n    var Math_max = Math.max;\n    var Math_clz32 = Math.clz32;\n    var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n\n        if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n\n            var shown = false;\n\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n\n              err('dependency: ' + dep);\n            }\n\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {}; // maps url to image data\n\n    Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n    var memoryInitializer = null;\n    var\n    /* show errors on likely calls to FS when it was not included */\n    FS = {\n      error: function () {\n        abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n      },\n      init: function () {\n        FS.error();\n      },\n      createDataFile: function () {\n        FS.error();\n      },\n      createPreloadedFile: function () {\n        FS.error();\n      },\n      createLazyFile: function () {\n        FS.error();\n      },\n      open: function () {\n        FS.error();\n      },\n      mkdev: function () {\n        FS.error();\n      },\n      registerDevice: function () {\n        FS.error();\n      },\n      analyzePath: function () {\n        FS.error();\n      },\n      loadFilesFromDB: function () {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module['FS_createDataFile'] = FS.createDataFile;\n    Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    function integrateWasmJS() {\n      var wasmBinaryFile = 'FFTW.wasm';\n\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = locateFile(wasmBinaryFile);\n      } // utilities\n\n\n      var wasmPageSize = 64 * 1024;\n      var info = {\n        'global': null,\n        'env': null,\n        'asm2wasm': asm2wasmImports,\n        'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n\n      };\n      var exports = null;\n\n      function mergeMemory(newBuffer) {\n        // The wasm instance creates its memory. But static init code might have written to\n        // buffer already, including the mem init file, and we must copy it over in a proper merge.\n        // TODO: avoid this copy, by avoiding such static init writes\n        // TODO: in shorter term, just copy up to the last static init write\n        var oldBuffer = Module['buffer'];\n\n        if (newBuffer.byteLength < oldBuffer.byteLength) {\n          err('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n        }\n\n        var oldView = new Int8Array(oldBuffer);\n        var newView = new Int8Array(newBuffer);\n        newView.set(oldView);\n        updateGlobalBuffer(newBuffer);\n        updateGlobalBufferViews();\n      }\n\n      function getBinary() {\n        try {\n          if (Module['wasmBinary']) {\n            return new Uint8Array(Module['wasmBinary']);\n          }\n\n          if (Module['readBinary']) {\n            return Module['readBinary'](wasmBinaryFile);\n          } else {\n            throw \"both async and sync fetching of the wasm failed\";\n          }\n        } catch (err) {\n          abort(err);\n        }\n      }\n\n      function getBinaryPromise() {\n        // if we don't have the binary yet, and have the Fetch api, use that\n        // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n        if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n          return fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            if (!response['ok']) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response['arrayBuffer']();\n          }).catch(function () {\n            return getBinary();\n          });\n        } // Otherwise, getBinary should be able to get it synchronously\n\n\n        return new Promise(function (resolve, reject) {\n          resolve(getBinary());\n        });\n      } // Create the wasm instance.\n      // Receives the wasm imports, returns the exports.\n\n\n      function createWasm(global, env, providedBuffer) {\n        if (typeof WebAssembly !== 'object') {\n          abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n          err('no native wasm support detected');\n          return false;\n        } // prepare memory import\n\n\n        if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n          err('no native wasm Memory in use');\n          return false;\n        }\n\n        env['memory'] = Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.\n\n        info['global'] = {\n          'NaN': NaN,\n          'Infinity': Infinity\n        };\n        info['global.Math'] = Math;\n        info['env'] = env; // handle a generated wasm instance, receiving its exports and\n        // performing other necessary setup\n\n        function receiveInstance(instance, module) {\n          exports = instance.exports;\n          if (exports.memory) mergeMemory(exports.memory);\n          Module['asm'] = exports;\n          removeRunDependency('wasm-instantiate');\n        }\n\n        addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n        // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n        // to any other async startup actions they are performing.\n\n        if (Module['instantiateWasm']) {\n          try {\n            return Module['instantiateWasm'](info, receiveInstance);\n          } catch (e) {\n            err('Module.instantiateWasm callback failed with error: ' + e);\n            return false;\n          }\n        } // Async compilation can be confusing when an error on the page overwrites Module\n        // (for example, if the order of elements is wrong, and the one defining Module is\n        // later), so we save Module and check it later.\n\n\n        var trueModule = Module;\n\n        function receiveInstantiatedSource(output) {\n          // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n          // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n          assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n          trueModule = null;\n          receiveInstance(output['instance'], output['module']);\n        }\n\n        function instantiateArrayBuffer(receiver) {\n          getBinaryPromise().then(function (binary) {\n            return WebAssembly.instantiate(binary, info);\n          }).then(receiver, function (reason) {\n            err('failed to asynchronously prepare wasm: ' + reason);\n            abort(reason);\n          });\n        } // Prefer streaming instantiation if available.\n\n\n        if (!Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n          WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }), info).then(receiveInstantiatedSource, function (reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n        } else {\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n\n        return {}; // no exports yet; we'll fill them in later\n      } // We may have a preloaded value in Module.asm, save it\n\n\n      Module['asmPreload'] = Module['asm']; // Memory growth integration code\n\n      var wasmReallocBuffer = function (size) {\n        var PAGE_MULTIPLE = 65536;\n        size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n\n        var old = Module['buffer'];\n        var oldSize = old.byteLength; // native wasm support\n\n        try {\n          var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n\n          if (result !== (-1 | 0)) {\n            // success in native wasm memory growth, get the buffer from the memory\n            return Module['buffer'] = Module['wasmMemory'].buffer;\n          } else {\n            return null;\n          }\n        } catch (e) {\n          console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);\n          return null;\n        }\n      };\n\n      Module['reallocBuffer'] = function (size) {\n        return wasmReallocBuffer(size);\n      }; // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n      // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n      // doesn't need to care that it is wasm or asm.js.\n\n\n      Module['asm'] = function (global, env, providedBuffer) {\n        // import table\n        if (!env['table']) {\n          assert(Module['wasmTableSize'] !== undefined);\n          var TABLE_SIZE = Module['wasmTableSize'];\n          var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\n\n          if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {\n            if (MAX_TABLE_SIZE !== undefined) {\n              env['table'] = new WebAssembly.Table({\n                'initial': TABLE_SIZE,\n                'maximum': MAX_TABLE_SIZE,\n                'element': 'anyfunc'\n              });\n            } else {\n              env['table'] = new WebAssembly.Table({\n                'initial': TABLE_SIZE,\n                element: 'anyfunc'\n              });\n            }\n          } else {\n            env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n          }\n\n          Module['wasmTable'] = env['table'];\n        }\n\n        if (!env['__memory_base']) {\n          env['__memory_base'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\n        }\n\n        if (!env['__table_base']) {\n          env['__table_base'] = 0; // table starts at 0 by default, in dynamic linking this will change\n        }\n\n        var exports = createWasm(global, env, providedBuffer);\n        assert(exports, 'binaryen setup failed (no wasm support?)');\n        return exports;\n      };\n    }\n\n    integrateWasmJS(); // === Body ===\n\n    var ASM_CONSTS = [];\n    STATIC_BASE = GLOBAL_BASE; // STATICTOP = STATIC_BASE + 35056;\n\n    /* global initializers */\n\n    __ATINIT__.push();\n\n    var STATIC_BUMP = 35056;\n    Module[\"STATIC_BASE\"] = STATIC_BASE;\n    Module[\"STATIC_BUMP\"] = STATIC_BUMP;\n    /* no memory initializer */\n\n    var tempDoublePtr = 36064;\n    assert(tempDoublePtr % 8 == 0);\n\n    function copyTempFloat(ptr) {\n      // functions, because inlining this code increases code size too much\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n    }\n\n    function copyTempDouble(ptr) {\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n      HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n      HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n      HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n      HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n    } // {{PRE_LIBRARY}}\n\n\n    function ___lock() {}\n\n    var SYSCALLS = {\n      buffers: [null, [], []],\n      printChar: function (stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: 0,\n      get: function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function () {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      get64: function () {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);else assert(high === -1);\n        return low;\n      },\n      getZero: function () {\n        assert(SYSCALLS.get() === 0);\n      }\n    };\n\n    function ___syscall140(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // llseek\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[result >> 2] = stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n\n    function ___syscall146(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // writev\n        // hack to support printf in FILESYSTEM=0\n        var stream = SYSCALLS.get(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n          for (var j = 0; j < len; j++) {\n            SYSCALLS.printChar(stream, HEAPU8[ptr + j]);\n          }\n\n          ret += len;\n        }\n\n        return ret;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall54(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // ioctl\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall6(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // close\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___unlock() {}\n\n    function _abort() {\n      Module['abort']();\n    }\n\n    function _emscripten_get_now() {\n      abort();\n    }\n\n    function _emscripten_get_now_is_monotonic() {\n      // return whether emscripten_get_now is guaranteed monotonic; the Date.now\n      // implementation is not :(\n      return ENVIRONMENT_IS_NODE || typeof dateNow !== 'undefined' || (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self['performance'] && self['performance']['now'];\n    }\n\n    function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value;else err('failed to set errno from JS');\n      return value;\n    }\n\n    function _clock_gettime(clk_id, tp) {\n      // int clock_gettime(clockid_t clk_id, struct timespec *tp);\n      var now;\n\n      if (clk_id === 0) {\n        now = Date.now();\n      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {\n        now = _emscripten_get_now();\n      } else {\n        ___setErrNo(22);\n\n        return -1;\n      }\n\n      HEAP32[tp >> 2] = now / 1000 | 0; // seconds\n\n      HEAP32[tp + 4 >> 2] = now % 1000 * 1000 * 1000 | 0; // nanoseconds\n\n      return 0;\n    }\n\n    function _gettimeofday(ptr) {\n      var now = Date.now();\n      HEAP32[ptr >> 2] = now / 1000 | 0; // seconds\n\n      HEAP32[ptr + 4 >> 2] = now % 1000 * 1000 | 0; // microseconds\n\n      return 0;\n    }\n\n    var _llvm_cos_f64 = Math_cos;\n    var _llvm_sin_f64 = Math_sin;\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n      return dest;\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      _emscripten_get_now = function _emscripten_get_now_actual() {\n        var t = process['hrtime']();\n        return t[0] * 1e3 + t[1] / 1e6;\n      };\n    } else if (typeof dateNow !== 'undefined') {\n      _emscripten_get_now = dateNow;\n    } else if (typeof self === 'object' && self['performance'] && typeof self['performance']['now'] === 'function') {\n      _emscripten_get_now = function () {\n        return self['performance']['now']();\n      };\n    } else if (typeof performance === 'object' && typeof performance['now'] === 'function') {\n      _emscripten_get_now = function () {\n        return performance['now']();\n      };\n    } else {\n      _emscripten_get_now = Date.now;\n    }\n\n    ;\n    var ASSERTIONS = true; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n\n    /** @type {function(string, boolean=, number=)} */\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 0xFF) {\n          if (ASSERTIONS) {\n            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n          }\n\n          chr &= 0xFF;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join('');\n    }\n\n    function nullFunc_didi(x) {\n      err(\"Invalid function pointer called with signature 'didi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_ii(x) {\n      err(\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iii(x) {\n      err(\"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiii(x) {\n      err(\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiiiiiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_vi(x) {\n      err(\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_vii(x) {\n      err(\"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiffi(x) {\n      err(\"Invalid function pointer called with signature 'viiffi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viii(x) {\n      err(\"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiii(x) {\n      err(\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiiiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    Module['wasmTableSize'] = 12930;\n    Module['wasmMaxTableSize'] = 12930;\n    Module.asmGlobalArg = {};\n    Module.asmLibraryArg = {\n      \"abort\": abort,\n      \"assert\": assert,\n      \"enlargeMemory\": enlargeMemory,\n      \"getTotalMemory\": getTotalMemory,\n      \"setTempRet0\": setTempRet0,\n      \"getTempRet0\": getTempRet0,\n      \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n      \"abortStackOverflow\": abortStackOverflow,\n      \"nullFunc_didi\": nullFunc_didi,\n      \"nullFunc_ii\": nullFunc_ii,\n      \"nullFunc_iii\": nullFunc_iii,\n      \"nullFunc_iiii\": nullFunc_iiii,\n      \"nullFunc_iiiiiii\": nullFunc_iiiiiii,\n      \"nullFunc_iiiiiiiiii\": nullFunc_iiiiiiiiii,\n      \"nullFunc_iiiiiiiiiii\": nullFunc_iiiiiiiiiii,\n      \"nullFunc_iiiiiiiiiiii\": nullFunc_iiiiiiiiiiii,\n      \"nullFunc_iiiiiiiiiiiiiii\": nullFunc_iiiiiiiiiiiiiii,\n      \"nullFunc_vi\": nullFunc_vi,\n      \"nullFunc_vii\": nullFunc_vii,\n      \"nullFunc_viiffi\": nullFunc_viiffi,\n      \"nullFunc_viii\": nullFunc_viii,\n      \"nullFunc_viiii\": nullFunc_viiii,\n      \"nullFunc_viiiii\": nullFunc_viiiii,\n      \"nullFunc_viiiiiii\": nullFunc_viiiiiii,\n      \"nullFunc_viiiiiiii\": nullFunc_viiiiiiii,\n      \"nullFunc_viiiiiiiii\": nullFunc_viiiiiiiii,\n      \"nullFunc_viiiiiiiiii\": nullFunc_viiiiiiiiii,\n      \"___lock\": ___lock,\n      \"___setErrNo\": ___setErrNo,\n      \"___syscall140\": ___syscall140,\n      \"___syscall146\": ___syscall146,\n      \"___syscall54\": ___syscall54,\n      \"___syscall6\": ___syscall6,\n      \"___unlock\": ___unlock,\n      \"_abort\": _abort,\n      \"_clock_gettime\": _clock_gettime,\n      \"_emscripten_get_now\": _emscripten_get_now,\n      \"_emscripten_get_now_is_monotonic\": _emscripten_get_now_is_monotonic,\n      \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"_gettimeofday\": _gettimeofday,\n      \"_llvm_cos_f64\": _llvm_cos_f64,\n      \"_llvm_sin_f64\": _llvm_sin_f64,\n      \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n      \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n      \"tempDoublePtr\": tempDoublePtr\n    }; // EMSCRIPTEN_START_ASM\n\n    var asm = Module[\"asm\"] // EMSCRIPTEN_END_ASM\n    (Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n    var real__fftwf_destroy_plan = asm[\"_fftwf_destroy_plan\"];\n\n    asm[\"_fftwf_destroy_plan\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_destroy_plan.apply(null, arguments);\n    };\n\n    var real__fftwf_execute = asm[\"_fftwf_execute\"];\n\n    asm[\"_fftwf_execute\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_execute.apply(null, arguments);\n    };\n\n    var real__fftwf_free = asm[\"_fftwf_free\"];\n\n    asm[\"_fftwf_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_free.apply(null, arguments);\n    };\n\n    var real__fftwf_malloc = asm[\"_fftwf_malloc\"];\n\n    asm[\"_fftwf_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_malloc.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_dft_1d = asm[\"_fftwf_plan_dft_1d\"];\n\n    asm[\"_fftwf_plan_dft_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_dft_1d.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_dft_2d = asm[\"_fftwf_plan_dft_2d\"];\n\n    asm[\"_fftwf_plan_dft_2d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_dft_2d.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_dft_c2r_1d = asm[\"_fftwf_plan_dft_c2r_1d\"];\n\n    asm[\"_fftwf_plan_dft_c2r_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_dft_c2r_1d.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_dft_r2c_1d = asm[\"_fftwf_plan_dft_r2c_1d\"];\n\n    asm[\"_fftwf_plan_dft_r2c_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_dft_r2c_1d.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_r2r_1d = asm[\"_fftwf_plan_r2r_1d\"];\n\n    asm[\"_fftwf_plan_r2r_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_r2r_1d.apply(null, arguments);\n    };\n\n    var real__fftwf_plan_r2r_2d = asm[\"_fftwf_plan_r2r_2d\"];\n\n    asm[\"_fftwf_plan_r2r_2d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fftwf_plan_r2r_2d.apply(null, arguments);\n    };\n\n    var real__free = asm[\"_free\"];\n\n    asm[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__free.apply(null, arguments);\n    };\n\n    var real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"];\n\n    asm[\"_llvm_bswap_i32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__llvm_bswap_i32.apply(null, arguments);\n    };\n\n    var real__malloc = asm[\"_malloc\"];\n\n    asm[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__malloc.apply(null, arguments);\n    };\n\n    var real__memmove = asm[\"_memmove\"];\n\n    asm[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__memmove.apply(null, arguments);\n    };\n\n    var real__sbrk = asm[\"_sbrk\"];\n\n    asm[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__sbrk.apply(null, arguments);\n    };\n\n    var real_establishStackSpace = asm[\"establishStackSpace\"];\n\n    asm[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_establishStackSpace.apply(null, arguments);\n    };\n\n    var real_setThrew = asm[\"setThrew\"];\n\n    asm[\"setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_setThrew.apply(null, arguments);\n    };\n\n    var real_stackAlloc = asm[\"stackAlloc\"];\n\n    asm[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackAlloc.apply(null, arguments);\n    };\n\n    var real_stackRestore = asm[\"stackRestore\"];\n\n    asm[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackRestore.apply(null, arguments);\n    };\n\n    var real_stackSave = asm[\"stackSave\"];\n\n    asm[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackSave.apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n\n    var _fftwf_destroy_plan = Module[\"_fftwf_destroy_plan\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_destroy_plan\"].apply(null, arguments);\n    };\n\n    var _fftwf_execute = Module[\"_fftwf_execute\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_execute\"].apply(null, arguments);\n    };\n\n    var _fftwf_free = Module[\"_fftwf_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_free\"].apply(null, arguments);\n    };\n\n    var _fftwf_malloc = Module[\"_fftwf_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_malloc\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_dft_1d = Module[\"_fftwf_plan_dft_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_dft_1d\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_dft_2d = Module[\"_fftwf_plan_dft_2d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_dft_2d\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_dft_c2r_1d = Module[\"_fftwf_plan_dft_c2r_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_dft_c2r_1d\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_dft_r2c_1d = Module[\"_fftwf_plan_dft_r2c_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_dft_r2c_1d\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_r2r_1d = Module[\"_fftwf_plan_r2r_1d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_r2r_1d\"].apply(null, arguments);\n    };\n\n    var _fftwf_plan_r2r_2d = Module[\"_fftwf_plan_r2r_2d\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fftwf_plan_r2r_2d\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_free\"].apply(null, arguments);\n    };\n\n    var _llvm_bswap_i32 = Module[\"_llvm_bswap_i32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n    };\n\n    var _memcpy = Module[\"_memcpy\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\n    };\n\n    var _memmove = Module[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memmove\"].apply(null, arguments);\n    };\n\n    var _memset = Module[\"_memset\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memset\"].apply(null, arguments);\n    };\n\n    var _sbrk = Module[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n    };\n\n    var establishStackSpace = Module[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n    };\n\n    var setThrew = Module[\"setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n\n    var dynCall_didi = Module[\"dynCall_didi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_didi\"].apply(null, arguments);\n    };\n\n    var dynCall_ii = Module[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n\n    var dynCall_iii = Module[\"dynCall_iii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiiii = Module[\"dynCall_iiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiiiiiii = Module[\"dynCall_iiiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiiiiiiii = Module[\"dynCall_iiiiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiiiiiiiii = Module[\"dynCall_iiiiiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiiiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiiiiiiiiiiii = Module[\"dynCall_iiiiiiiiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\n    };\n\n    var dynCall_vii = Module[\"dynCall_vii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiffi = Module[\"dynCall_viiffi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiffi\"].apply(null, arguments);\n    };\n\n    var dynCall_viii = Module[\"dynCall_viii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiii = Module[\"dynCall_viiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiii = Module[\"dynCall_viiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiiii = Module[\"dynCall_viiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiiiii = Module[\"dynCall_viiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiiiiii = Module[\"dynCall_viiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiiiiiii = Module[\"dynCall_viiiiiiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiiiiiii\"].apply(null, arguments);\n    };\n\n    ; // === Auto-generated postamble setup entry stuff ===\n\n    Module['asm'] = asm;\n    if (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function () {\n      abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"ccall\"] = ccall;\n    Module[\"cwrap\"] = cwrap;\n    if (!Module[\"setValue\"]) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getValue\"]) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocate\"]) Module[\"allocate\"] = function () {\n      abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getMemory\"]) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function () {\n      abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"ENV\"]) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS\"]) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"GL\"]) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getLEB\"]) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addFunction\"]) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynCall\"]) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackSave\"]) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"establishStackSpace\"]) Module[\"establishStackSpace\"] = function () {\n      abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"print\"]) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"printErr\"]) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getTempRet0\"]) Module[\"getTempRet0\"] = function () {\n      abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"setTempRet0\"]) Module[\"setTempRet0\"] = function () {\n      abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n      get: function () {\n        abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", {\n      get: function () {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      get: function () {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", {\n      get: function () {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    }); // Modularize mode returns a function, which can be called to\n    // create instances. The instances provide a then() method,\n    // must like a Promise, that receives a callback. The callback\n    // is called when the module is ready to run, with the module\n    // as a parameter. (Like a Promise, it also returns the module\n    // so you can use the output of .then(..)).\n\n    Module['then'] = function (func) {\n      // We may already be ready to run code at this time. if\n      // so, just queue a call to the callback.\n      if (Module['calledRun']) {\n        func(Module);\n      } else {\n        // we are not ready to call then() yet. we must call it\n        // at the same time we would call onRuntimeInitialized.\n        var old = Module['onRuntimeInitialized'];\n\n        Module['onRuntimeInitialized'] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n    /**\n     * @constructor\n     * @extends {Error}\n     * @this {ExitStatus}\n     */\n\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    ;\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n    var calledMain = false;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!Module['calledRun']) run();\n      if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n    /** @type {function(Array=)} */\n\n\n    function run(args) {\n      args = args || Module['arguments'];\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n      if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n      function doRun() {\n        if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n\n      checkStackCookie();\n    }\n\n    Module['run'] = run;\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var print = out;\n      var printErr = err;\n      var has = false;\n\n      out = err = function (x) {\n        has = true;\n      };\n\n      try {\n        // it doesn't matter if it fails\n        var flush = flush_NO_FILESYSTEM;\n        if (flush) flush(0);\n      } catch (e) {}\n\n      out = print;\n      err = printErr;\n\n      if (has) {\n        warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n        warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n      }\n    }\n\n    function exit(status, implicit) {\n      checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n      // don't need to do anything here and can just leave. if the status is\n      // non-zero, though, then we need to report it.\n      // (we may have warned about this earlier, if a situation justifies doing so)\n\n      if (implicit && Module['noExitRuntime'] && status === 0) {\n        return;\n      }\n\n      if (Module['noExitRuntime']) {\n        // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n        if (!implicit) {\n          err('exit(' + status + ') called, but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n        }\n      } else {\n        ABORT = true;\n        EXITSTATUS = status;\n        exitRuntime();\n        if (Module['onExit']) Module['onExit'](status);\n      }\n\n      Module['quit'](status, new ExitStatus(status));\n    }\n\n    var abortDecorators = [];\n\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what);\n      } else {\n        what = '';\n      }\n\n      ABORT = true;\n      EXITSTATUS = 1;\n      var extra = '';\n      var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n      if (abortDecorators) {\n        abortDecorators.forEach(function (decorator) {\n          output = decorator(output, what);\n        });\n      }\n\n      throw output;\n    }\n\n    Module['abort'] = abort;\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    Module[\"noExitRuntime\"] = true;\n    run(); // {{MODULE_ADDITIONS}}\n\n    return FFTWModule;\n  };\n}();\n\nif (true) module.exports = FFTWModule;else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), \"/\"))\n\n//# sourceURL=webpack:///./src/FFTW.js?");

/***/ }),

/***/ "./src/FFTW.wasm":
/*!***********************!*\
  !*** ./src/FFTW.wasm ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"FFTW.wasm\";\n\n//# sourceURL=webpack:///./src/FFTW.wasm?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fftw = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\n__webpack_require__(/*! ./FFTW.wasm */ \"./src/FFTW.wasm\");\n\nwindow.fftw = fftw;\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const FFTWModule = __webpack_require__(/*! ./FFTW.js */ \"./src/FFTW.js\");\n\nconst FFTW_ESTIMATE = 1 << 6;\nconst FFTW_R2HC = 0;\nconst FFTW_HC2R = 1;\nconst FFTW_DHT = 2;\nconst FFTW_REDFT00 = 3;\nconst FFTW_REDFT10 = 5;\nconst FFTW_REDFT01 = 4;\nconst FFTW_REDFT11 = 6;\nconst FFTW_RODFT00 = 7;\nconst FFTW_RODFT10 = 9;\nconst FFTW_RODFT01 = 8;\nconst FFTW_RODFT11 = 10;\nconst FFTW_FORWARD = -1;\nconst FFTW_BACKWARD = 1;\nconst fftw = FFTWModule();\nfftw['ready'] = false;\nfftw['onReady'] = null;\n\nfftw['onRuntimeInitialized'] = () => {\n  const fftwf_plan_dft_r2c_1d = fftw.cwrap('fftwf_plan_dft_r2c_1d', 'number', ['number', 'number', 'number', 'number']);\n  const fftwf_plan_dft_c2r_1d = fftw.cwrap('fftwf_plan_dft_c2r_1d', 'number', ['number', 'number', 'number', 'number']); // fftw_plan fftw_plan_r2r_1d(int n, double *in, double *out,\n  //                            fftw_r2r_kind kind, unsigned flags);\n\n  const fftwf_plan_r2r_1d = fftw.cwrap('fftwf_plan_r2r_1d', 'number', ['number', 'number', 'number', 'number']); // fftw_plan fftw_plan_r2r_2d(int n0, int n1, double *in, double *out,\n  //                            fftw_r2r_kind kind0, fftw_r2r_kind kind1,\n  //                            unsigned flags);\n\n  const fftwf_plan_r2r_2d = fftw.cwrap('fftwf_plan_r2r_2d', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number']); // fftw_plan fftw_plan_dft_1d(int n, fftw_complex *in, fftw_complex *out,\n  //                            int sign, unsigned flags)\n\n  const fftwf_plan_dft_1d = fftw.cwrap('fftwf_plan_dft_1d', 'number', ['number', 'number', 'number', 'number', 'number']); // fftw_plan fftw_plan_dft_2d(int n0, int n1,\n  //                            fftw_complex *in, fftw_complex *out,\n  //                            int sign, unsigned flags)\n\n  const fftwf_plan_dft_2d = fftw.cwrap('fftwf_plan_dft_2d', 'number', ['number', 'number', 'number', 'number', 'number', 'number']);\n  const fftwf_execute = fftw.cwrap('fftwf_execute', 'void', ['number']);\n  const fftwf_destroy_plan = fftw.cwrap('fftwf_destroy_plan', 'void', ['number']);\n  const fftwf_free = fftw.cwrap('fftwf_free', 'void', ['number']);\n  const fftwf_malloc = fftw.cwrap('fftwf_malloc', 'number', ['number']);\n  fftw.c2c = {};\n  fftw.r2c = {};\n  fftw.r2r = {};\n\n  fftw.c2c.fft2d = function (n0, n1) {\n    this.n0 = n0;\n    this.n1 = n1;\n    this.size = n0 * n1;\n    this.c0ptr = fftwf_malloc(2 * 4 * this.size);\n    this.c1ptr = fftwf_malloc(2 * 4 * this.size);\n    this.c0 = new Float32Array(fftw.HEAPU8.buffer, this.c0ptr, 2 * this.size); // two for complex\n\n    this.c1 = new Float32Array(fftw.HEAPU8.buffer, this.c1ptr, 2 * this.size);\n    this.fplan = fftwf_plan_dft_2d(this.n0, this.n1, this.c0ptr, this.c1ptr, FFTW_FORWARD, FFTW_ESTIMATE);\n    this.iplan = fftwf_plan_dft_2d(this.n0, this.n1, this.c1ptr, this.c0ptr, FFTW_BACKWARD, FFTW_ESTIMATE);\n\n    this.forward = function (cpx) {\n      this.c0.set(cpx);\n      fftwf_execute(this.fplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.c1ptr, 2 * this.size);\n    };\n\n    this.inverse = function (cpx) {\n      this.c1.set(cpx);\n      fftwf_execute(this.iplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.c0ptr, 2 * this.size);\n    };\n\n    this.dispose = function () {\n      fftwf_destroy_plan(this.fplan);\n      fftwf_destroy_plan(this.iplan);\n      fftwf_free(this.c0ptr);\n      fftwf_free(this.c1ptr);\n    };\n  };\n\n  fftw.c2c.fft1d = function (size) {\n    this.size = size; // this.c0ptr = fftwf_malloc(2*4*size + 2*4*size)\n    // this.c1ptr = this.c0ptr\n\n    this.c0ptr = fftwf_malloc(2 * 4 * this.size);\n    this.c1ptr = fftwf_malloc(2 * 4 * this.size);\n    this.c0 = new Float32Array(fftw.HEAPU8.buffer, this.c0ptr, 2 * size);\n    this.c1 = new Float32Array(fftw.HEAPU8.buffer, this.c1ptr, 2 * size);\n    this.fplan = fftwf_plan_dft_1d(size, this.c0ptr, this.c1ptr, FFTW_FORWARD, FFTW_ESTIMATE);\n    this.iplan = fftwf_plan_dft_1d(size, this.c1ptr, this.c0ptr, FFTW_BACKWARD, FFTW_ESTIMATE);\n\n    this.forward = function (cpx) {\n      this.c0.set(cpx);\n      fftwf_execute(this.fplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.c1ptr, 2 * this.size);\n    };\n\n    this.inverse = function (cpx) {\n      this.c1.set(cpx);\n      fftwf_execute(this.iplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.c0ptr, 2 * this.size);\n    };\n\n    this.dispose = function () {\n      fftwf_destroy_plan(this.fplan);\n      fftwf_destroy_plan(this.iplan);\n      fftwf_free(this.c0ptr);\n      fftwf_free(this.c1ptr);\n    };\n  };\n\n  fftw.r2c.fft1d = function (size) {\n    this.size = size;\n    this.rptr = fftwf_malloc(size * 4 + (size + 2) * 4);\n    this.cptr = this.rptr + size * 4;\n    this.r = new Float32Array(fftw.HEAPU8.buffer, this.rptr, size);\n    this.c = new Float32Array(fftw.HEAPU8.buffer, this.cptr, size + 2);\n    this.fplan = fftwf_plan_dft_r2c_1d(size, this.rptr, this.cptr, FFTW_ESTIMATE);\n    this.iplan = fftwf_plan_dft_c2r_1d(size, this.cptr, this.rptr, FFTW_ESTIMATE);\n\n    this.forward = function (real) {\n      this.r.set(real);\n      fftwf_execute(this.fplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.cptr, this.size + 2);\n    };\n\n    this.inverse = function (cpx) {\n      this.c.set(cpx);\n      fftwf_execute(this.iplan);\n      return new Float32Array(fftw.HEAPU8.buffer, this.rptr, this.size);\n    };\n\n    this.dispose = function () {\n      fftwf_destroy_plan(this.fplan);\n      fftwf_destroy_plan(this.iplan);\n      fftwf_free(this.rptr);\n    };\n  };\n\n  const r2r1dFactory = (forwardType, inverseType) => {\n    return function (size) {\n      this.size = size;\n      this.rptr = fftwf_malloc(size * 4 + size * 4);\n      this.cptr = this.rptr;\n      this.r = new Float32Array(fftw.HEAPU8.buffer, this.rptr, size);\n      this.c = new Float32Array(fftw.HEAPU8.buffer, this.cptr, size);\n      this.fplan = fftwf_plan_r2r_1d(size, this.rptr, this.cptr, forwardType, FFTW_ESTIMATE);\n      this.iplan = fftwf_plan_r2r_1d(size, this.cptr, this.rptr, inverseType, FFTW_ESTIMATE);\n\n      this.forward = function (real) {\n        this.r.set(real);\n        fftwf_execute(this.fplan);\n        return new Float32Array(fftw.HEAPU8.buffer, this.cptr, this.size);\n      };\n\n      this.inverse = function (cpx) {\n        this.c.set(cpx);\n        fftwf_execute(this.iplan);\n        return new Float32Array(fftw.HEAPU8.buffer, this.rptr, this.size);\n      };\n\n      this.dispose = function () {\n        fftwf_destroy_plan(this.fplan);\n        fftwf_destroy_plan(this.iplan);\n        fftwf_free(this.rptr);\n      };\n    };\n  };\n\n  const r2r2dFactory = (forwardType, inverseType) => {\n    return function (n0, n1) {\n      this.n0 = n0;\n      this.n1 = n1;\n      this.size = this.n0 * this.n1;\n      this.rptr = fftwf_malloc(this.size * 4);\n      this.cptr = fftwf_malloc(this.size * 4);\n      this.r = new Float32Array(fftw.HEAPU8.buffer, this.rptr, this.size);\n      this.c = new Float32Array(fftw.HEAPU8.buffer, this.cptr, this.size);\n      this.fplan = fftwf_plan_r2r_2d(this.n0, this.n1, this.rptr, this.cptr, forwardType, forwardType, FFTW_ESTIMATE);\n      this.iplan = fftwf_plan_r2r_2d(this.n0, this.n1, this.cptr, this.rptr, inverseType, inverseType, FFTW_ESTIMATE);\n\n      this.forward = function (real) {\n        this.r.set(real);\n        fftwf_execute(this.fplan);\n        return new Float32Array(fftw.HEAPU8.buffer, this.cptr, this.size);\n      };\n\n      this.inverse = function (cpx) {\n        this.c.set(cpx);\n        fftwf_execute(this.iplan);\n        return new Float32Array(fftw.HEAPU8.buffer, this.rptr, this.size);\n      };\n\n      this.dispose = function () {\n        fftwf_destroy_plan(this.fplan);\n        fftwf_destroy_plan(this.iplan);\n        fftwf_free(this.rptr);\n      };\n    };\n  };\n\n  fftw.r2r.fft1d = r2r1dFactory(FFTW_R2HC, FFTW_HC2R);\n  fftw.r2r.dct1d = r2r1dFactory(FFTW_REDFT10, FFTW_REDFT01);\n  fftw.r2r.dst1d = r2r1dFactory(FFTW_RODFT10, FFTW_RODFT01);\n  fftw.r2r.fft2d = r2r2dFactory(FFTW_R2HC, FFTW_HC2R);\n  fftw.r2r.dct2d = r2r2dFactory(FFTW_REDFT10, FFTW_REDFT01);\n  fftw.r2r.dst2d = r2r2dFactory(FFTW_RODFT10, FFTW_RODFT01);\n  fftw['ready'] = true;\n\n  if (fftw['onReady'] !== null) {\n    fftw['onReady'](fftw);\n  }\n}; // fftw.ready =  function () {\n//   return new Promise ((resolve, reject) => {\n//     fftw['onRuntimeInitialized'] = resolve\n//   }).then(() => {\n//     return fftw\n//   })\n// }\n\n\nmodule.exports = fftw;\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/index.js?");

/***/ })

/******/ });